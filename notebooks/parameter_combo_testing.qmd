---
title: "Parameter Combo Testing"
author: "Laurie Lyon"
format: html
editor: visual
---

# Comparison of MICOM-predicted growth rates and measured changes in abundance from time series data

Load in libraries

```{r}
library(cowplot) # to plot grid
library(glue) # to format and interpolate a string
library(lme4) # for linear modeling 
library(tidyverse) 
library(ggh4x) # ggplot2 extension, includes nested facets
library(broom)
```

Load in combined data (simulated growth rates + actual CLR-transformed growth rates) generated from "sim_and_real_data.r"

```{r}
sim_real_data <- read.csv("../data/combined_sim_real_data.csv", sep = "," )
```

# Correlation

I want to see the correlation between

-   can I write a for loop to cycle though all of these combinations - top level: folder_name/parameters, further nested by taxon, possibly further nested by before vs. after onset of illness?

-   how can I extract the values that I want from the Spearman test. Do I filter first by significance?

-   Can I average the rho values across all the taxa in a single folder?

-   How can I quantify what parameters are performing better than others

    -   rank by p-value and rho, count instances of each parameter and where they fall in the ranking?

```{r}
growth_F01_agora201_gurobi_wd_08_Akkermansia <- sim_real_data %>% 
  filter(folder_name == "growth_F01_agora201_gurobi_wd_08", taxon == "Akkermansia")

spearman_cor <- cor.test(growth_F01_agora201_gurobi_wd_08_Akkermansia$growth_rate, growth_F01_agora201_gurobi_wd_08_Akkermansia$clr_change_abund, method = c("spearman"))

spearman_cor
```

Using group_by and broom library to cycle through parameter combinations and taxa

```{r}
spearman_results <- sim_real_data %>% 
  #group by folder_name and taxon then perform spearman correlation tests systematically 
  group_by(folder_name, taxon, subject_id, model_db, diet, tradeoff, date_vs_onset_illness) %>% 
  #nest rows into a list-column of dfs, each unique group has its own df with all rows belonging to that group (data column)
  nest() %>% 
  #first filter out groups with non-zero variance (was causing errors in several samples)
  #map() applies a function to each element of a vector (map_dbl return a vector of type dbl)
  mutate(
    var_growth = map_dbl(data, ~ sd(.x$growth_rate, na.rm=TRUE)), 
    var_abund = map_dbl(data, ~sd(.x$clr_change_abund, na.rm=TRUE))
  ) %>% 
  #removes zero variance cases
  filter(var_growth > 0 & var_abund > 0) %>% 
  mutate(
    #map applies a function to each element of a vector
    spearman = map(data, ~ cor.test(.x$growth_rate, 
                                    .x$clr_change_abund, 
                                    method = "spearman", 
                                    #received warning about computing exact p-value with ties
                                    #default to approx. p-values to deal with this
                                    exact = FALSE)),
    #extracts the rho and p-values from spearman with broom::tidy()
    tidy_results = map(spearman, tidy)
  ) %>% 
  #extract tidy results into a new df 
  unnest(tidy_results) %>% 
  select(-data, -spearman, -var_growth, -var_abund)

nrow(spearman_results)
summary(spearman_results)
```

filter results by significance using broom

```{r}
significant_spearman_p <- spearman_results %>% 
  filter(p.value < 0.05)

nrow(significant_spearman_p)
summary(significant_spearman_p)
```

average rho values across all taxa within the same folder

-   I arranged these in descending order of mean rho, but the highest rho often means there is only 1 significant taxa with a strong prediction...

-   How do I actually want to weight significant taxa vs. total taxa - fraction of total vs amount of significant taxa?

-   Do I look at all taxa within each time point separately?

```{r}
#for all Spearman coefficients
avg_rho_by_folder <- spearman_results %>% 
  group_by(folder_name, subject_id, model_db, diet, tradeoff, date_vs_onset_illness) %>% 
  #mean and median rho indicates predictive strength across all taxa
  #mean is more sensitive to outliers than median, so just looking at both
  summarise(mean_rho = mean(estimate, na.rm=TRUE),
            median_rho = median(estimate, na.rm=TRUE), 
            significant_taxa = sum(p.value < 0.05), 
            total_taxa = n()) %>% 
  arrange(desc(mean_rho)) 

#for only significant Spearman coefficients
avg_significant_rho_by_folder <- significant_spearman_p %>% 
  group_by(folder_name, subject_id, model_db, diet, tradeoff, date_vs_onset_illness) %>% 
  #mean and median rho indicates predictive strength across all taxa
  summarise(mean_rho = mean(estimate, na.rm=TRUE),
            median_rho = median(estimate, na.rm=TRUE), 
            significant_taxa = sum(p.value < 0.05), 
            total_taxa = n()) %>% 
  arrange(desc(mean_rho))

# summary(avg_rho_by_folder)
# summary(avg_significant_rho_by_folder)
```

```{r}
ranked_parameters <- spearman_results %>%
  mutate(significant = p.value < 0.05) %>%
  group_by(folder_name, subject_id, diet, tradeoff) %>%
  summarise(
    significant_count = sum(significant),
    total_taxa = n(),
    mean_rho = mean(estimate, na.rm=TRUE),
    median_p = median(p.value, na.rm=TRUE)
  ) %>%
  arrange(desc(mean_rho), desc(significant_count))

```

Trying to generate a comprehensive performance summary based on significant, positively correlated values

```{r}
performance_summary <- spearman_results %>%
  mutate(significant = p.value < 0.05, 
         positive = estimate > 0, 
         significant_positive = significant & positive) %>%  
  group_by(folder_name, subject_id, model_db, diet, tradeoff, date_vs_onset_illness) %>%
  summarise(
    mean_rho = mean(estimate[significant_positive], na.rm = TRUE),                
    median_rho = median(estimate[significant_positive], na.rm = TRUE),              
    significant_positive_taxa = sum(significant_positive),                      
    total_taxa = n(),                                        
    percent_significant_positive = (significant_positive_taxa / total_taxa)*100 
  ) %>%
  #only want positive rho values 
  filter(significant_positive_taxa > 0) %>% 
  arrange(desc(percent_significant_positive), desc(median_rho))      
```

quantify which parameters perform better than others

-   I want to be able to make a list of parameters/folder that works best for each subject

```{r, fig.width=10, fig.height=12}
spearman_performance_summary_plot_M01 <- performance_summary %>%
  filter(subject_id == "M01") %>% 
  ggplot(aes(x = reorder(folder_name, percent_significant_positive), 
             y = percent_significant_positive, 
             fill = median_rho)) +
  geom_bar(stat = "identity", color = "black") +
  coord_flip() +
  scale_fill_gradient(low = "lightyellow", high = "darkgreen") +
  labs(
    x = "Parameter Combination (folder_name)", 
    y = "% Significant Positive Correlations",
    fill = "Median Rho",
    title = "Ranking MICOM Parameter Sets by Predictive Accuracy",
    subtitle = "Subject M01 after onset of illness\nRanked by % Significant Positive Taxa\nColor intensity indicates Median Positive Spearman's rho"
  ) +
  theme_minimal() +
  theme(legend.position = "right")

spearman_performance_summary_plot_M01
```

```{r, fig.width=10, fig.height=12}
spearman_performance_summary_plot_F01 <- performance_summary %>%
  filter(subject_id == "F01", date_vs_onset_illness == "after") %>% 
  ggplot(aes(x = reorder(folder_name, percent_significant_positive), 
             y = percent_significant_positive, 
             fill = median_rho)) +
  geom_bar(stat = "identity", color = "black") +
  coord_flip() +
  scale_fill_gradient(low = "lightyellow", high = "darkgreen") +
  labs(
    x = "Parameter Combination (folder_name)", 
    y = "% Significant Positive Correlations",
    fill = "Median Rho",
    title = "Ranking MICOM Parameter Sets by Predictive Accuracy",
    subtitle = "Subject F01: Ranked by % Significant Positive Taxa\nColor intensity indicates Median Positive Spearman's rho"
  ) +
  theme_minimal() +
  theme(legend.position = "right")

spearman_performance_summary_plot_F01
```

Want to automate graphical representations for each subject both before and after onset of illness

```{r, fig.width=10, fig.height=15}
#define the categories I want to cycle through
#unique() returns a vector, df, or array like x but with duplicate elements removed
subjects <- unique(performance_summary$subject_id)
onset_timing <- unique(performance_summary$date_vs_onset_illness)

#create and store the plots in a nested list like my data from earlier
#expand.grid() creates a df from all combinations of supplied vectors 
predictive_accuracy_plots <- expand.grid(subject = subjects, onset = onset_timing) %>% 
#pmap maps in parallel 
  pmap(function(subject, onset) {
    performance_summary %>% 
      filter(subject_id == subject, 
             date_vs_onset_illness == onset) %>% 
      ggplot(aes(x = reorder(folder_name, percent_significant_positive), 
                 y = percent_significant_positive, 
                 fill = median_rho)) +
      #makes bar plot with actual data values (percent_significant_positive)
      #default is stat = "counts"
      geom_bar(stat = "identity", color = "black") +
      #put folder names on the side for easier readability
      coord_flip() +
      scale_fill_gradient(low = "lightyellow",
                          high = "darkgreen") +
      labs(x = "Parameter Combination (folder_name)", 
        y = "% Significant Positive Correlations",
        fill = "Median Rho",
        title = paste("MICOM Parameter Rankings for ", subject),
        subtitle = paste("Time relative to illness onset: ", onset,
                         "\nRanked by % Significant Positive Taxa; color = Median Rho")
      ) +
      theme_minimal() +
      theme(legend.position = "right")
    
  })

#name the plots
names(predictive_accuracy_plots) <- expand.grid(
  subject = subjects, onset = onset_timing) %>%
  mutate(plot_name = paste(subject, onset, sep = "_")) %>%
  pull(plot_name)
```

```{r}
predictive_accuracy_plots$M01_before
predictive_accuracy_plots$M01_after
predictive_accuracy_plots$F01_before
predictive_accuracy_plots$F01_after
predictive_accuracy_plots$M02_before
predictive_accuracy_plots$M02_after
```

## Linear Modeling

want to try linear modeling next to account for more than just monotonic relationships like Spearman

```{r echo =FALSE}
source("~/Tools/Madi_Code/art_lmer_functions.R")
```

Mixed effect linear modeling (random effect + fixed effect)

```{r}
# micom_growth_rate_model <- lmer(growth_rate ~ abundance + (abundance | taxon),
#                                 data = prevalent_micom_rates)
```

```{r, fig.width=8, fig.height=7.5}
# abundance_vs_growth_rate <- prevalent_micom_rates %>% 
#   ggplot(aes(x = abundance, y = growth_rate)) + 
#   geom_point() +
#   geom_line(aes(y = predict(micom_growth_rate_model)),
#             color="red") +
#   facet_wrap(~taxon,
#              scales="free",
#              ncol=3) +
#   theme_bw(base_size = 15) +
#   labs(x = "Relative Abundance",
#        y = "Growth Rate",
#        title = "Relative Abundance vs. MICOM Growth Rate"
```

## Modeling

\*\*need to come back to mixed linear model for sim_real_growth

```{r}
sim_real_growth_model1 <- lmer(clr_change_abund ~ growth_rate
                               * model_db
                               * diet 
                               * tradeoff 
                               + (1 | taxon)
                               + (1 | subject_id), 
                               data = sim_real_data)

summary(sim_real_growth_model1)
# sim_real_growth_model1 <- lmer(clr_change_abund ~ growth_rate + (1 | taxon),
#                      data = sim_real_data)
# 
# sim_real_growth_model2 <- lmer(log2FC_abund ~ sample_growth_rate_clr +
#                                  (sample_growth_rate_clr | taxon),
#                                data = sim_real_data)
# 
# sim_real_growth_model3 <- lmer(log2FC_abund ~ sample_growth_rate_clr * 
#                                  abundance +
#                                 (abundance | taxon),
#                                data = sim_real_data)

# anova(sim_real_growth_model1, sim_real_growth_model3)
# anova(sim_real_growth_model1, sim_real_growth_model2)
# anova(sim_real_growth_model2, sim_real_growth_model3)
```
